---
layout: single
title: "질문 모음 - 짧은 답변"
date: 2025-01-10
toc: true
toc_sticky: true
toc_label: "목차"
toc_icon: "list"
---
- kotlin
	- 자바와 코틀린의 차이점
	- 코틀린의 장점
	- Coroutine
		- 코루틴 개념
		- 동작 방식 깊게 설명
		- 코루틴 life-cycle
		- 코루틴 사용 방법
		- 코루틴을 사용하는 경우
		- 코루틴 사용시 주의점
- AOP
	- AOP란
	- AOP를 사용할 때 주의할 점
- 비동기
	- 비동기 프레임워크 종류
	- 비동기 처리를 할 때 고려해야 할 사항(아키텍쳐 적으로)
	- 비동기의 단점, 주의사항
- DB
	- 파티셔닝과 샤딩의 차이
	- JdbcTemplate, Mybatis, Jpa, Querydsl등 다양한 라이브러리의 장점과 단점, 차이점
	- 테이블 설계시 중요 요소
	- JPA 사용할 때 문제가 될 수 있는 부분에 대해 설명
	- JPA 사용시 고아객체, entity 순회 이슈
	- 트랜잭션이 처리되는 과정
- Spring
	- 스프링의 요청 처리 과정
	- 필터와 인터셉터 차이
	- Spring AOP, DI, IOC 설명
	- Webflux
		- Spring MVC에서 Webflux 전환시 리소스적으로 달라지는 부분 (쿠버네티스 HPA 설정, 모니터링 방법 등)
	- Spring MVC 환경에서 트랜잭션이 걸린 메서드의 동작 방식과 라이프 사이클
	- 엔티티의 라이프 사이클
	- 엔티티 인서트 될 때 흐름
	- 트랜잭션 readOnly=true, false 차이점
	- 배치잡 프로세스가 있을 때 청크를 나눠서 실행하는 플로우일 경우, 청크를 구성하는 방식
- 패턴
	- 아웃소싱과 CQRS에 대한 설명
	- MSA 보상 트랜잭션
- 정규화, 비정규화 개념 설명
---
### Kotlin

#### 자바와 코틀린의 차이점
1. **문법 간결성**: 코틀린은 보일러플레이트 코드를 줄이고, 더 간결한 문법을 제공합니다.
   - `var`, `val`을 사용한 변수 선언.
   - 세미콜론 생략 가능.
2. **Null Safety**: 코틀린은 NullPointerException을 방지하기 위해 Null 안전성을 내장.
   - Nullable 타입과 Non-nullable 타입을 명시적으로 구분.
3. **확장 함수(Extension Functions)**: 기존 클래스에 메서드를 추가하지 않고도 기능 확장 가능.
4. **타입 추론**: 코틀린은 타입을 명시하지 않아도 컴파일러가 추론 가능.
5. **스마트 캐스트**: 타입 체크 후 자동으로 캐스팅을 지원.
6. **함수형 프로그래밍 지원**: 고차 함수, 람다 표현식 등 함수형 프로그래밍을 지원.

#### 코틀린의 장점
1. **생산성 증가**: 간결한 문법과 Null 안전성으로 코드 작성 속도 향상.
2. **Java와의 완벽한 호환성**: Java 코드를 그대로 사용하거나, Java 라이브러리를 쉽게 사용할 수 있음.
3. **코루틴 지원**: 비동기 프로그래밍이 간편.
4. **안전성**: NullPointerException 방지, 컴파일 시점에 오류 발견 가능.
5. **안드로이드 지원 강화**: 안드로이드 개발에 최적화된 언어.

#### Coroutine
##### 코루틴 개념
- 코루틴은 경량 스레드로, 비동기 코드를 더 간결하고 직관적으로 작성할 수 있도록 지원합니다.

##### 동작 방식 깊게 설명
- 코루틴은 메인 스레드를 차단하지 않으면서 비동기 작업을 수행.
- `suspend` 함수로 코루틴 내에서 중단점 설정 가능.
- 코루틴 디스패처를 통해 특정 스레드에서 실행하도록 제어.
- `launch`, `async` 같은 빌더를 사용하여 코루틴을 생성하고 실행.

##### 코루틴 Life-cycle
1. **생성 (New)**: 코루틴이 생성되고 준비 단계.
2. **활성 (Active)**: 코루틴이 실행 중이거나 대기 상태.
3. **완료 (Completed)**: 코루틴이 작업을 완료.
4. **취소 (Cancelled)**: 실행 도중 취소.

##### 코루틴 사용 방법
1. **코루틴 빌더**: `launch`, `async`, `runBlocking` 등을 사용.
2. **디스패처**: `Dispatchers.IO`, `Dispatchers.Main` 등으로 실행 컨텍스트를 지정.
3. **suspend 함수**: 중단 가능한 함수로 비동기 작업 수행.

##### 코루틴을 사용하는 경우
- 네트워크 호출, 데이터베이스 작업 등 비동기 작업이 필요할 때.
- UI 스레드를 차단하지 않고 백그라운드 작업을 처리할 때.

##### 코루틴 사용 시 주의점
1. **취소 처리**: `Job` 객체를 사용하여 코루틴을 적절히 취소해야 함.
2. **블로킹 코드 사용 금지**: 코루틴 내에서는 블로킹 코드를 피하고 `suspend` 함수를 사용.
3. **리소스 누수 방지**: 코루틴 스코프를 적절히 관리하여 리소스 누수를 방지.

---
### AOP (Aspect-Oriented Programming)

#### AOP란?
AOP는 핵심 비즈니스 로직 코드와 공통적으로 적용되는 부가적인 기능(로깅, 트랜잭션 관리, 보안 등)을 분리하여 모듈화하는 프로그래밍 패러다임입니다. 이를 통해 코드 중복을 줄이고, 비즈니스 로직을 깔끔하게 유지할 수 있습니다.

##### 주요 개념
1. **Aspect**: 
   - 공통 관심사를 모듈화한 단위입니다.
   - 예: 로깅, 트랜잭션 관리, 보안 검증 등.

2. **Join Point**:
   - Aspect가 적용될 수 있는 프로그램 실행 지점입니다.
   - 일반적으로 메서드 호출, 예외 처리, 필드 접근 등이 해당됩니다.

3. **Advice**:
   - Join Point에서 실행될 구체적인 작업입니다.
   - 종류:
     - **Before**: 메서드 실행 전 실행.
     - **After**: 메서드 실행 후 실행.
     - **AfterReturning**: 메서드가 정상적으로 반환된 후 실행.
     - **AfterThrowing**: 메서드에서 예외가 발생한 후 실행.
     - **Around**: 메서드 실행 전후로 실행, 메서드 실행을 제어할 수 있음.

4. **Pointcut**:
   - 특정 Join Point를 지정하는 표현식입니다.
   - 예를 들어, 특정 패키지의 모든 메서드에 로깅을 적용하려는 경우, 패키지 이름을 기준으로 Pointcut을 설정할 수 있습니다.

5. **Weaving**:
   - Aspect를 실제 코드에 적용하는 과정입니다.
   - Weaving은 컴파일 시, 로드 시, 런타임 시 이루어질 수 있습니다.
     - **컴파일 타임 Weaving**: 컴파일 단계에서 Aspect 적용.
     - **로드 타임 Weaving**: 클래스 로딩 시점에 Aspect 적용.
     - **런타임 Weaving**: 애플리케이션 실행 중에 프록시 객체를 통해 Aspect 적용.

#### AOP의 장점
1. **중복 코드 제거**: 공통 기능을 하나의 Aspect로 모듈화하여 여러 곳에서 재사용 가능.
2. **비즈니스 로직의 집중**: 핵심 로직과 부가 기능이 분리되어 비즈니스 로직에 집중할 수 있음.
3. **유지보수 용이**: 공통 기능을 중앙에서 관리하므로 유지보수 작업이 단순화됨.

#### AOP를 사용할 때 주의할 점
1. **과도한 사용 방지**:
   - 모든 공통 기능을 AOP로 처리하려는 유혹을 피해야 합니다.
   - 불필요하게 많은 Aspect를 사용하면 코드가 복잡해지고 이해하기 어려워질 수 있습니다.

2. **성능 고려**:
   - AOP는 런타임 시점에 프록시 객체를 생성하고 Join Point에서 Advice를 실행하기 때문에 약간의 성능 오버헤드가 발생합니다.
   - 성능이 중요한 경우에는 AOP 적용 범위를 최소화하거나 성능 영향을 철저히 검토해야 합니다.

3. **디버깅 어려움**:
   - AOP는 코드 흐름을 변경할 수 있어, 예상치 못한 동작이 발생할 수 있습니다.
   - 디버깅 과정에서 Join Point와 Advice의 실행 순서를 명확히 이해하고 있어야 합니다.

4. **Pointcut의 정확성**:
   - 너무 광범위하거나 불명확한 Pointcut 설정은 예기치 않은 코드에 Aspect가 적용될 위험이 있습니다.
   - 정확한 조건을 사용하여 Pointcut을 정의하는 것이 중요합니다.

5. **테스트 복잡성**:
   - AOP로 인한 코드 흐름 변경은 테스트 시에도 영향을 미칩니다.
   - 각 Aspect에 대한 단위 테스트와 통합 테스트를 신중하게 설계해야 합니다.

### AOP 주요 개념 상세 설명

#### 1. **Aspect**
- **정의**: Aspect는 여러 모듈에서 공통적으로 사용되는 기능을 정의한 모듈입니다. 예를 들어, 로깅, 트랜잭션 관리, 보안 검증 등이 Aspect로 구현될 수 있습니다.
- **구성 요소**:
  - **Advice**: 실제 실행되는 부가 작업.
  - **Pointcut**: Advice가 실행될 지점을 결정하는 규칙.

#### 2. **Join Point**
- **정의**: 프로그램 실행 중 Aspect가 적용될 수 있는 모든 지점을 의미합니다. 
- **예시**:
  - 메서드 호출 시점.
  - 예외가 던져지는 시점.
  - 필드에 접근하는 시점.
- **주의점**: Join Point는 구현에 따라 달라질 수 있으며, Spring AOP에서는 주로 메서드 호출이 Join Point로 사용됩니다.

#### 3. **Advice**
- **정의**: Join Point에서 실행되는 구체적인 동작을 정의하는 코드입니다.
- **종류 및 설명**:
  - **Before Advice**:
    - 메서드 실행 전에 실행됩니다.
    - 주로 입력 파라미터 검증이나 초기화 작업에 사용됩니다.
    - 예: 메서드 호출 전에 사용자의 인증 여부를 확인.
  
  - **After Advice**:
    - 메서드가 실행된 후에 실행됩니다. 메서드의 성공 여부와 관계없이 실행됩니다.
    - 주로 리소스 정리, 로그 작성 등에 사용됩니다.
  
  - **AfterReturning Advice**:
    - 메서드가 정상적으로 실행된 후에 실행됩니다.
    - 반환 값을 조작하거나 로그로 기록할 때 사용됩니다.
  
  - **AfterThrowing Advice**:
    - 메서드 실행 중 예외가 발생했을 때 실행됩니다.
    - 예외 처리 로직이나 로그 작성에 사용됩니다.
  
  - **Around Advice**:
    - 메서드 실행 전후에 실행되며, 메서드 실행을 직접 제어할 수 있습니다.
    - 메서드 호출을 감싸는 형태로 실행되며, 실행을 중단하거나 결과를 변경할 수 있습니다.
    - 가장 강력하지만, 사용 시 신중해야 합니다. 예를 들어 트랜잭션 관리를 직접 제어할 때 유용합니다.

#### 4. **Pointcut**
- **정의**: 특정 Join Point를 선택하는 규칙이나 표현식입니다. Pointcut은 Advice와 함께 사용되며, 어디에 Advice가 적용될지를 결정합니다.
- **표현식**:
  - 특정 패키지 내의 모든 메서드에 대해 적용: `execution(* com.example.service..*(..))`
  - 특정 어노테이션이 붙은 메서드에 대해 적용: `@annotation(org.springframework.transaction.annotation.Transactional)`
- **활용 예시**:
  - 특정 클래스나 메서드에만 Aspect를 적용하거나, 특정 조건에 맞는 지점에서만 실행하도록 설정할 수 있습니다.

#### 5. **Weaving**
- **정의**: Aspect와 비즈니스 로직을 결합하는 과정입니다. 즉, Aspect를 코드에 적용하는 것을 의미합니다.
- **시점에 따른 분류**:
  - **컴파일 타임 Weaving**:
    - 컴파일 시점에 Aspect를 코드에 적용합니다.
    - 예: AspectJ 컴파일러 사용.
  - **로드 타임 Weaving**:
    - 클래스 로더가 클래스를 메모리에 로드할 때 Aspect를 적용합니다.
    - 런타임 성능에 조금 더 영향을 미칠 수 있습니다.
  - **런타임 Weaving**:
    - 애플리케이션 실행 시점에 프록시를 통해 Aspect를 적용합니다.
    - Spring AOP는 런타임 Weaving 방식을 사용하며, 주로 프록시 기반으로 동작합니다.

---
### 비동기 프로그래밍 (Asynchronous Programming)

#### 1. **비동기 프레임워크 종류**
비동기 프로그래밍을 지원하는 다양한 프레임워크가 존재합니다. 주요 프레임워크는 다음과 같습니다:

##### **Java 기반**
- **CompletableFuture (Java 8 이상)**:
  - Java의 기본 라이브러리로, 비동기 작업을 처리하고 결과를 조합할 수 있습니다.
  - `thenApply`, `thenCompose` 등으로 비동기 작업을 연결하거나, `join`, `get`을 통해 결과를 동기적으로 기다릴 수 있습니다.

- **Spring WebFlux**:
  - 비동기 논블로킹 I/O를 지원하는 리액티브 프로그래밍 모델입니다.
  - `Mono`와 `Flux`를 사용하여 비동기 스트림을 처리합니다.

- **Vert.x**:
  - 이벤트 루프 기반으로, 고성능 비동기 어플리케이션을 개발할 수 있는 프레임워크입니다.
  - 다양한 언어 지원과 비동기 작업을 위한 `Future`와 `Handler`를 제공합니다.

##### **다른 언어 기반**
- **Node.js**:
  - 자바스크립트 기반의 비동기 이벤트 루프 아키텍처를 제공하여 비동기 I/O 작업에 최적화되어 있습니다.
  - `async/await` 구문과 `Promise` 객체를 사용하여 비동기 코드를 작성합니다.

- **Kotlin Coroutines**:
  - 코루틴을 통해 비동기 작업을 쉽게 작성할 수 있습니다.
  - `suspend` 함수와 `launch`, `async`와 같은 빌더를 통해 비동기 작업을 처리합니다.

#### 2. **비동기 처리를 할 때 고려해야 할 사항 (아키텍처적 관점)**
비동기 프로그래밍을 설계할 때 고려해야 할 주요 요소는 다음과 같습니다:

##### **1) 성능과 확장성**
- 비동기 프로그래밍은 I/O 작업이 많은 애플리케이션에서 스레드 차단을 피하고 성능을 향상시킵니다.
- 적절한 비동기 프레임워크를 선택하여 리소스 소비를 최적화하고, 확장성을 고려한 설계를 해야 합니다.

##### **2) 에러 처리 및 복구**
- 비동기 환경에서는 에러가 다른 스레드나 이벤트 루프에서 발생하므로 에러 전파와 복구 메커니즘을 명확히 설계해야 합니다.
- 예를 들어, Java의 `CompletableFuture`는 `exceptionally` 메서드를 통해 에러를 처리합니다.

##### **3) 흐름 제어**
- 비동기 처리의 특성상 여러 작업이 동시에 실행될 수 있습니다. 이때, 과도한 작업 실행을 방지하기 위한 **백프레셔**(Backpressure) 관리가 필요합니다.
  - Spring WebFlux에서는 `Flux`의 `onBackpressureDrop`, `onBackpressureBuffer` 메서드를 사용하여 백프레셔를 관리할 수 있습니다.

##### **4) 상태 관리**
- 비동기 작업은 일반적으로 공유 상태를 피하는 것이 좋습니다. 상태 공유가 필요한 경우, 스레드 안전성을 보장할 수 있는 동기화 메커니즘이 필요합니다.

##### **5) 트랜잭션 관리**
- 비동기 처리 중 트랜잭션의 경계를 관리하는 것이 어렵습니다.
- 트랜잭션이 필요하다면 명시적인 트랜잭션 관리나, Saga 패턴 같은 분산 트랜잭션 관리 전략을 고려해야 합니다.

#### 3. **비동기의 단점 및 주의사항**
비동기 프로그래밍은 여러 장점을 제공하지만, 그에 따른 단점과 주의사항도 존재합니다:

##### **1) 디버깅 어려움**
- 비동기 코드에서는 호출 스택이 분리되어 있기 때문에 디버깅이 어려울 수 있습니다.
- 특히, 비동기 작업 간의 흐름이나 에러 발생 위치를 추적하기가 까다롭습니다.
  - 이를 해결하기 위해 로깅을 강화하거나, 디버깅 툴을 사용하여 작업 흐름을 추적해야 합니다.

##### **2) 복잡한 코드 흐름**
- 비동기 작업은 작업 간의 의존성과 순서를 명확히 정의해야 합니다. 그렇지 않으면 코드가 복잡해지고 유지보수가 어려워집니다.
  - 코드 가독성을 유지하기 위해 `async/await`, `suspend` 함수와 같은 명확한 비동기 구문을 사용하는 것이 좋습니다.

##### **3) 에러 전파**
- 비동기 환경에서는 에러가 메인 스레드로 전파되지 않기 때문에, 에러 처리를 명시적으로 설계해야 합니다.
  - 예: `CompletableFuture.exceptionally`, `CoroutineExceptionHandler`를 사용하여 에러를 명시적으로 처리.

##### **4) 리소스 누수**
- 비동기 작업이 완료되지 않거나 취소되지 않으면 리소스가 해제되지 않는 문제가 발생할 수 있습니다.
  - 항상 작업 완료나 취소를 처리하고, 리소스를 적절히 해제해야 합니다.

##### **5) 스레드 안전성**
- 공유 리소스를 다루는 비동기 코드에서는 스레드 안전성을 확보해야 합니다.
  - `synchronized` 블록이나, `ReentrantLock` 등을 사용하여 동기화를 관리하거나, 불변 객체 사용을 고려해야 합니다.

---
### 데이터베이스 (DB) 관련 질문들에 대한 답변

#### 1. **파티셔닝과 샤딩의 차이**

##### **파티셔닝 (Partitioning)**
- **정의**: 하나의 데이터베이스 내에서 테이블을 여러 조각으로 나누는 방식.
- **목적**: 데이터 분산 저장 및 성능 최적화.
- **종류**:
  - **수평 파티셔닝 (Horizontal Partitioning)**: 행(Row) 단위로 데이터를 나눔.
    - 예: 고객 데이터를 지역별로 분할.
  - **수직 파티셔닝 (Vertical Partitioning)**: 열(Column) 단위로 데이터를 나눔.
    - 예: 자주 사용하는 열과 그렇지 않은 열을 분리.
- **특징**:
  - 하나의 데이터베이스 인스턴스 내에서 관리.
  - 쿼리 성능 향상 및 관리 효율성을 제공.

##### **샤딩 (Sharding)**
- **정의**: 데이터를 여러 데이터베이스 인스턴스에 나누어 저장하는 방식.
- **목적**: 대량의 데이터를 분산 처리하여 성능과 확장성을 향상.
- **방법**:
  - **키 기반 샤딩**: 특정 키 값을 기준으로 데이터를 나눔.
  - **범위 기반 샤딩**: 값의 범위를 기준으로 데이터를 나눔.
  - **해시 기반 샤딩**: 해시 함수를 사용하여 데이터를 나눔.
- **특징**:
  - 데이터베이스 인스턴스를 여러 개 사용하는 분산 시스템.
  - 데이터베이스 간의 동기화와 일관성 관리가 필요.

#### 2. **JdbcTemplate, MyBatis, JPA, Querydsl의 장점과 단점**

##### **JdbcTemplate**
- **장점**:
  - 간단한 SQL을 사용할 때 빠르고 직관적.
  - 명시적인 SQL 작성이 가능하여 SQL 제어가 용이.
- **단점**:
  - 코드 중복이 많고, 객체 매핑을 수동으로 해야 하므로 생산성이 낮음.

##### **MyBatis**
- **장점**:
  - SQL을 XML이나 어노테이션으로 관리하여 명시적인 SQL 제어 가능.
  - 복잡한 쿼리에 유리하며, 객체 매핑 지원.
- **단점**:
  - SQL 작성과 관리가 복잡할 수 있음.
  - 객체 매핑과 로직 분리가 어려울 수 있음.

##### **JPA (Java Persistence API)**
- **장점**:
  - ORM(Object-Relational Mapping) 프레임워크로 객체와 테이블 간의 매핑을 자동화.
  - 데이터베이스 독립성 제공, 유지보수 용이.
  - 자동으로 쿼리를 생성하여 생산성 향상.
- **단점**:
  - 복잡한 쿼리 작성 시 HQL/JPQL 사용의 제한점.
  - 러닝 커브가 존재하며, 성능 튜닝이 필요할 수 있음.

##### **Querydsl**
- **장점**:
  - 타입 안전한 쿼리 작성 가능.
  - 복잡한 쿼리를 동적이고 안전하게 생성할 수 있음.
  - IDE 지원과 자동 완성 기능으로 생산성 향상.
- **단점**:
  - 초기 설정이 복잡할 수 있음.
  - 단순한 쿼리에 대해서는 오히려 비효율적일 수 있음.

#### 3. **테이블 설계 시 중요 요소**
1. **정규화**: 데이터 중복을 최소화하고, 데이터 무결성을 유지.
2. **인덱스**: 조회 성능 향상을 위한 적절한 인덱스 설정.
3. **참조 무결성**: 외래 키를 통해 데이터 일관성 유지.
4. **확장성**: 데이터 증가에 따른 확장성을 고려한 설계.
5. **분리**: 읽기와 쓰기 성능 향상을 위한 테이블 분리.
6. **데이터 타입 선택**: 효율적인 스토리지 사용과 성능 최적화를 위해 적절한 데이터 타입 선택.

#### 4. **JPA 사용할 때 문제가 될 수 있는 부분**

##### **1) N+1 문제**
- **설명**: 한 번의 쿼리로 데이터를 가져온 후, 연관된 데이터를 추가로 조회할 때 여러 번의 쿼리가 발생.
- **해결**: `@EntityGraph`, `join fetch`, `@BatchSize` 등을 사용하여 해결.

##### **2) Lazy Loading과 Eager Loading**
- **Lazy Loading**: 연관된 엔티티를 실제로 사용할 때 로딩.
- **Eager Loading**: 연관된 엔티티를 즉시 로딩.
- **주의점**: 불필요한 데이터 로딩으로 인한 성능 저하를 방지하기 위해 적절한 전략 사용 필요.

##### **3) 캐싱 문제**
- **설명**: 1차 캐시와 2차 캐시 사용 시 동기화 및 일관성 관리 필요.
- **해결**: 캐시 전략을 명확히 설정하고, 동기화 메커니즘을 구현.

#### 5. **JPA 사용 시 고아 객체, Entity 순회 이슈**

##### **고아 객체**:
- 부모 엔티티와의 연관관계가 끊어진 자식 엔티티를 자동으로 삭제.
- `@OneToMany(orphanRemoval = true)`로 설정 가능.
- **주의점**: 잘못된 연관관계 설정으로 인해 의도치 않은 데이터 삭제가 발생할 수 있음.

##### **Entity 순회**:
- 엔티티 간 순환 참조가 있을 경우 무한 루프 발생 가능.
- **해결**: `@JsonIgnore`, `@JsonBackReference` 등을 사용하여 순환 참조 방지.

#### 6. **트랜잭션이 처리되는 과정**
1. **트랜잭션 시작**: 비즈니스 로직 시작 시 트랜잭션 매니저가 트랜잭션 시작.
2. **작업 수행**: 데이터베이스 작업 수행 (Insert, Update, Delete 등).
3. **트랜잭션 커밋/롤백**: 작업 성공 시 커밋, 실패 시 롤백.
4. **트랜잭션 종료**: 작업 종료 후 트랜잭션 매니저가 트랜잭션을 종료.

---
### 1. **Spring의 요청 처리 과정**
스프링에서 요청이 처리되는 과정을 자세히 살펴보겠습니다:

1. **클라이언트 요청**: 사용자가 브라우저 또는 애플리케이션에서 요청을 보냅니다.
2. **DispatcherServlet**: 모든 요청은 **DispatcherServlet**으로 전달됩니다. 이 서블릿은 프런트 컨트롤러 역할을 하며, 요청을 적절한 핸들러로 라우팅합니다.
3. **HandlerMapping**: 이 컴포넌트는 어떤 컨트롤러가 요청을 처리할지를 결정합니다. 여러 유형의 핸들러 매핑 전략을 사용할 수 있으며, 주로 **@RequestMapping** 어노테이션이 사용됩니다.
4. **HandlerAdapter**: 선택된 핸들러를 실행하기 위해 적절한 **HandlerAdapter**를 찾습니다. 이 어댑터는 컨트롤러 메서드를 호출하여 요청을 처리합니다.
5. **Controller 실행**: 컨트롤러 메서드가 호출되고, 필요한 비즈니스 로직이 수행됩니다.
6. **ModelAndView 반환**: 컨트롤러는 **ModelAndView** 객체를 반환하여, 모델 데이터와 뷰 이름을 포함합니다.
7. **ViewResolver**: **ViewResolver**는 반환된 뷰 이름을 실제 뷰 객체로 변환합니다. 예를 들어, **JSP**, **Thymeleaf** 등의 뷰로 변환합니다.
8. **뷰 렌더링 및 응답 반환**: 마지막으로 뷰가 렌더링되어 클라이언트에게 HTML이나 JSON 등의 형식으로 응답이 반환됩니다.

### 2. **필터와 인터셉터 차이**
필터와 인터셉터의 차이점을 더욱 자세히 보겠습니다:

- **필터 (Filter)**:
  - **Servlet API**에 의해 정의된 기능으로, 모든 서블릿 요청과 응답을 가로챌 수 있습니다.
  - **doFilter** 메서드를 사용하여 요청 전후에 작업을 수행합니다.
  - 필터는 서블릿 컨테이너 레벨에서 동작하며, 모든 요청 경로에 대해 동작할 수 있습니다.
  - 주로 **인증**, **로깅**, **요청 수정** 등에 사용됩니다.

- **인터셉터 (Interceptor)**:
  - 스프링 **HandlerInterceptor** 인터페이스를 구현하여 사용됩니다.
  - **preHandle**, **postHandle**, **afterCompletion** 메서드를 통해 요청의 전, 후, 그리고 뷰 렌더링 후에 작업을 수행할 수 있습니다.
  - 스프링 MVC의 **DispatcherServlet**이 요청을 처리하는 과정에서 특정 컨트롤러에 대한 요청만 가로챌 수 있습니다.
  - **로깅**, **인증 및 권한 확인**, **공통 로직 삽입** 등에 자주 사용됩니다.

### 3. **Spring AOP, DI, IOC**
각 개념을 더 자세히 설명하겠습니다:

- **AOP (Aspect-Oriented Programming)**:
  - 프로그램의 핵심 기능과 공통 관심사를 분리하여 코드 중복을 줄입니다.
  - **Aspect**: 공통 관심사를 모듈화한 단위로, 주로 **@Aspect** 어노테이션을 사용합니다.
  - **Advice**: 특정 시점에 실행되는 코드로, **Before**, **After**, **Around** 등이 있습니다.
  - **Join Point**: Advice가 적용될 수 있는 모든 지점.
  - **Pointcut**: Join Point 중 Advice가 실제로 적용되는 지점을 정의.

- **DI (Dependency Injection)**:
  - 객체 간의 의존성을 스프링이 관리하며, 개발자는 객체의 생성과 주입을 신경 쓰지 않아도 됩니다.
  - **@Autowired**, **@Inject** 등을 사용하여 의존성을 주입합니다.
  - 객체의 생성, 관리, 소멸을 컨테이너가 담당하여 코드의 유연성과 테스트 가능성을 높입니다.

- **IoC (Inversion of Control)**:
  - 객체의 생성과 라이프사이클 관리를 개발자가 아닌 컨테이너가 맡아 관리합니다.
  - **ApplicationContext**는 스프링 IoC 컨테이너로, 객체의 생성, 설정, 관리 등을 담당합니다.

### 4. **Spring Webflux**
Spring Webflux는 리액티브 프로그래밍을 지원하며, 다음과 같은 특징이 있습니다:

- **논블로킹 I/O**: 요청-응답 과정에서 블로킹 없이 처리가 이루어져 더 높은 동시성을 제공합니다.
- **스레드 효율성**: 동기 방식보다 훨씬 적은 스레드로 많은 요청을 처리할 수 있습니다.
- **백프레셔**: 데이터 처리 속도에 맞게 데이터 전송을 조절하여 시스템 과부하를 방지합니다.
- **Webflux 전환 시 리소스 변화**:
  - **CPU, 메모리 사용량 감소**: 더 적은 리소스로 동일한 양의 요청을 처리 가능.
  - **HPA 설정 최적화**: 쿠버네티스에서 HPA를 설정할 때, 리소스 사용량을 최적화하여 더 높은 효율성을 얻을 수 있습니다.

### 5. **트랜잭션 처리 과정**
스프링 트랜잭션 관리자는 다음 단계를 거쳐 트랜잭션을 관리합니다:

1. **트랜잭션 시작**: 트랜잭션 매니저가 **@Transactional** 어노테이션을 통해 새 트랜잭션을 시작하거나 기존 트랜잭션을 재사용합니다.
2. **트랜잭션 경계 내 작업 수행**: 데이터베이스 작업이 트랜잭션 내에서 수행되며, 실패 시 전체 작업이 롤백됩니다.
3. **커밋 또는 롤백**: 모든 작업이 성공하면 커밋되고, 예외 발생 시 롤백됩니다.

### 6. **트랜잭션 readOnly 설정**
- **readOnly=true**:
  - 읽기 전용 트랜잭션으로, 데이터 수정이 발생하지 않습니다.
  - 데이터베이스의 특정 최적화를 활용하여 읽기 성능을 향상시킬 수 있습니다.
  
- **readOnly=false**:
  - 데이터 읽기 및 쓰기 작업이 모두 가능하며, 일반적인 트랜잭션 설정입니다.

### 7. **엔티티 라이프 사이클**
- **New**: 새로 생성된 엔티티로, 아직 영속성 컨텍스트에 포함되지 않은 상태.
- **Managed**: 영속성 컨텍스트에 포함되어 관리되는 상태.
- **Detached**: 영속성 컨텍스트에서 분리된 상태로, 변경 사항이 데이터베이스에 반영되지 않습니다.
- **Removed**: 삭제 예정 상태로 표시된 엔티티.

### 8. **엔티티 인서트 흐름**
새로운 엔티티를 **persist** 하면 영속성 컨텍스트에 저장되고, **flush** 시점에 데이터베이스에 삽입됩니다.

### 9. **배치잡 프로세스와 청크 처리**
배치잡에서 데이터를 **청크**로 나누어 처리할 때:
- **읽기(Read)**: 청크 단위로 데이터를 읽어옵니다.
- **처리(Process)**: 읽어온 데이터를 가공하거나 변환합니다.
- **쓰기(Write)**: 처리된 데이터를 데이터베이스에 저장합니다.

---
### 1. **아웃소싱과 CQRS에 대한 설명**

#### 아웃소싱 (Outsourcing)
- **개념**: 아웃소싱은 회사가 특정 비즈니스 프로세스나 서비스, 특히 IT 서비스, 소프트웨어 개발 등을 외부 조직에 맡기는 것을 의미합니다.
- **장점**:
  - **비용 절감**: 저렴한 노동력을 이용하여 운영 비용을 절감할 수 있습니다.
  - **전문성**: 전문적인 기술과 경험을 가진 외부 인력을 활용할 수 있습니다.
  - **핵심 업무 집중**: 내부 리소스를 핵심 비즈니스에 집중시킬 수 있습니다.
- **단점**:
  - **통제력 상실**: 외부 파트너에 대한 통제력이 줄어듭니다.
  - **품질 관리**: 외부에서 제공하는 서비스의 품질이 기대에 못 미칠 수 있습니다.
  - **커뮤니케이션 문제**: 언어, 시간대, 문화 차이로 인해 커뮤니케이션에 어려움이 있을 수 있습니다.

#### CQRS (Command Query Responsibility Segregation)
- **개념**: CQRS는 시스템의 읽기 작업(쿼리)과 쓰기 작업(명령)의 책임을 분리하는 패턴입니다.
- **장점**:
  - **확장성**: 읽기와 쓰기 모델을 분리하여 각각 독립적으로 확장할 수 있습니다.
  - **성능 향상**: 읽기 작업에 특화된 데이터 모델을 사용하여 쿼리 성능을 최적화할 수 있습니다.
  - **복잡성 감소**: 명령과 쿼리 로직을 분리하여 코드의 복잡성을 줄일 수 있습니다.
- **단점**:
  - **복잡한 설계**: 읽기와 쓰기 모델을 별도로 관리해야 하므로 초기 설계가 복잡해질 수 있습니다.
  - **데이터 일관성**: 데이터 동기화와 일관성 유지가 어렵습니다.
  - **추가 비용**: 두 개의 모델을 유지 관리해야 하므로 비용이 증가할 수 있습니다.

### 2. **MSA 보상 트랜잭션 (Microservices Architecture Compensation Transaction)**

#### MSA에서의 보상 트랜잭션
- **개념**: MSA(마이크로서비스 아키텍처)에서는 각 서비스가 독립적으로 트랜잭션을 관리합니다. 이를 통해 전통적인 단일 트랜잭션 경계를 넘어서게 되며, **보상 트랜잭션**이 필요합니다.
- **보상 트랜잭션**: 하나의 서비스에서 발생한 작업이 실패하거나 롤백이 필요한 경우, 이미 완료된 작업을 원상태로 되돌리기 위한 트랜잭션입니다.
  
#### 특징:
- **분산 트랜잭션**: MSA에서는 하나의 작업이 여러 서비스에 걸쳐 있을 수 있으므로, 분산된 환경에서의 트랜잭션 관리를 위해 보상 트랜잭션이 중요합니다.
- **예시**: 예를 들어, 주문 서비스와 결제 서비스가 연동되어 있을 때, 주문이 실패하면 결제 취소를 보상 트랜잭션으로 수행합니다.

#### 보상 트랜잭션 구현 시 고려 사항:
- **이벤트 기반 아키텍처**: 보상 트랜잭션은 보통 이벤트 기반으로 구현되며, 서비스 간의 메시징을 통해 트랜잭션 상태를 관리합니다.
- **최소한의 보상 필요성**: 가능하면 보상 트랜잭션이 필요 없도록 설계하는 것이 바람직합니다.
- **데이터 일관성**: 데이터 일관성을 유지하는 것이 중요하며, 최종적 일관성(eventual consistency)을 목표로 합니다.

### 3. **정규화와 비정규화 개념 설명**

#### 정규화 (Normalization)
- **개념**: 정규화는 데이터베이스의 데이터를 중복 없이 효율적으로 구성하기 위해 테이블을 분리하고 관계를 설정하는 과정입니다.
- **목적**:
  - **데이터 중복 제거**: 중복 데이터를 줄여 저장 공간을 절약하고 데이터 무결성을 보장합니다.
  - **데이터 무결성**: 데이터 일관성과 정확성을 유지합니다.
- **정규형**:
  - **1NF (제1정규형)**: 각 컬럼은 원자값(더 이상 나눌 수 없는 값)이어야 합니다.
  - **2NF (제2정규형)**: 1NF를 만족하면서 부분적 종속성을 제거.
  - **3NF (제3정규형)**: 2NF를 만족하면서 이행적 종속성을 제거.
  - **BCNF (보이스-코드 정규형)**: 모든 결정자가 후보 키여야 합니다.

#### 비정규화 (Denormalization)
- **개념**: 성능 향상을 위해 정규화된 데이터베이스를 일부러 비정규화하여 중복 데이터를 허용하는 것입니다.
- **목적**:
  - **성능 향상**: 조인 연산을 줄이고 조회 성능을 개선합니다.
  - **데이터 액세스 속도 증가**: 읽기 작업이 빈번한 경우 비정규화가 효과적일 수 있습니다.
- **단점**:
  - **데이터 중복 증가**: 중복 데이터로 인해 저장 공간이 증가하고, 데이터 무결성 유지가 어려워질 수 있습니다.
  - **수정 복잡성 증가**: 중복된 데이터를 수정할 때 복잡성이 증가합니다.

---
---
### 1. **자바와 코틀린의 차이점**

코틀린은 자바와 함께 JVM(자바 가상 머신)에서 실행되지만, 두 언어 사이에는 몇 가지 중요한 차이점이 있습니다.

#### 주요 차이점:
- **문법 간결성**:
  - **코틀린**: 더 간결하고 직관적인 문법을 제공합니다. 예를 들어, **Null Safety**와 **타입 추론**을 통해 코드 길이를 줄일 수 있습니다.
  - **자바**: 문법이 더 장황하며, boilerplate 코드가 많이 필요합니다.
  
- **Null 안전성**:
  - **코틀린**: 기본적으로 null 값을 허용하지 않으며, **?** 연산자를 사용하여 null 가능성을 명시해야 합니다. 이를 통해 **NullPointerException**(NPE)을 방지합니다.
  - **자바**: null 참조를 허용하며, NPE가 자주 발생하는 문제점이 있습니다.

- **확장 함수**:
  - **코틀린**: 기존 클래스에 메서드를 추가할 수 있는 **확장 함수**를 지원하여, 코드의 가독성과 재사용성을 높입니다.
  - **자바**: 이러한 기능이 없으며, 클래스나 메서드를 변경하려면 상속이나 유틸리티 클래스가 필요합니다.

- **데이터 클래스**:
  - **코틀린**: **data class**를 사용하면 자동으로 **equals**, **hashCode**, **toString** 메서드가 생성되어, 데이터 객체 생성이 간단합니다.
  - **자바**: 모든 메서드를 수동으로 오버라이드해야 하므로 번거롭습니다.

- **코루틴 지원**:
  - **코틀린**: 내장 **Coroutine**을 통해 비동기 프로그래밍을 간단하게 구현할 수 있습니다.
  - **자바**: 비동기 처리를 위해 **CompletableFuture**, **ExecutorService** 등을 사용하며, 코드가 복잡해질 수 있습니다.

### 2. **코틀린의 장점**

#### 코틀린의 주요 장점은 다음과 같습니다:
- **생산성 향상**: 간결한 문법과 다양한 언어 기능 덕분에 개발 속도가 빨라집니다.
- **Null 안전성**: NullPointerException을 방지하는 메커니즘이 내장되어 있어, 코드 안정성이 높아집니다.
- **함수형 프로그래밍 지원**: 고차 함수, 람다 표현식 등 함수형 프로그래밍 요소를 쉽게 사용할 수 있습니다.
- **자바와의 완벽한 호환성**: 기존 자바 코드를 쉽게 활용할 수 있으며, 두 언어를 혼합하여 사용할 수 있습니다.
- **커뮤니티 및 도구 지원**: JetBrains에서 개발하고 지원하며, Android 개발에서 공식적으로 권장되는 언어입니다.

### 3. **코루틴 개념**

#### 코루틴(Coroutine)이란?
- **코루틴**은 비동기 프로그래밍을 쉽게 할 수 있도록 지원하는 경량 스레드입니다. **스레드**와 달리 **중단(suspend)**과 **재개(resume)**가 가능한 함수입니다.
- **비동기 작업**을 더 간단하고 직관적으로 작성할 수 있습니다.

### 4. **코루틴 동작 방식 깊게 설명**

#### 동작 방식:
- **suspend 함수**: 코루틴은 **suspend** 키워드를 사용하여 비동기 작업을 정의합니다. 이는 실행 중간에 일시 중단될 수 있는 함수를 나타냅니다.
- **코루틴 컨텍스트**: 코루틴은 컨텍스트 내에서 실행되며, 이는 스레드, 디스패처 등을 정의합니다.
- **디스패처**:
  - **Dispatchers.Main**: UI 작업에 사용.
  - **Dispatchers.IO**: 입출력 작업에 최적화.
  - **Dispatchers.Default**: CPU 집약적인 작업에 사용.

#### 예제:
```kotlin
fun main() = runBlocking {
    launch(Dispatchers.IO) {
        val result = fetchData()
        println(result)
    }
}

suspend fun fetchData(): String {
    delay(1000) // 1초 동안 대기
    return "Data retrieved"
}
```

- **runBlocking**: 메인 스레드에서 코루틴을 시작.
- **launch**: 새로운 코루틴을 시작하고, 비동기적으로 작업을 수행.
- **delay**: 일시 중단(suspend) 함수를 사용하여 비동기 대기.

### 5. **코루틴 Life-Cycle**

코루틴은 다음과 같은 생명 주기를 가집니다:
1. **생성(Created)**: 코루틴이 생성되지만 아직 실행되지 않음.
2. **활성(Active)**: 실행 중이거나 일시 중단된 상태.
3. **일시 중단(Suspended)**: **suspend** 함수로 인해 실행이 중단된 상태.
4. **완료(Completed)**: 작업이 완료되어 종료된 상태.
5. **취소(Cancelled)**: 실행 도중 취소된 상태.

### 6. **코루틴 사용 방법**

코루틴을 사용하는 방법은 간단합니다:
- **runBlocking**: 테스트나 메인 함수에서 동기적으로 코루틴을 실행할 때 사용.
- **launch**: 새로운 코루틴을 비동기적으로 실행할 때 사용.
- **async/await**: 비동기 작업을 병렬로 수행하고, 결과를 반환받을 때 사용.

#### 사용 예:
```kotlin
fun main() = runBlocking {
    val result = async { compute() }
    println("결과: ${result.await()}")
}

suspend fun compute(): Int {
    delay(1000)
    return 42
}
```

### 7. **코루틴을 사용하는 경우**

코루틴은 다음과 같은 경우에 사용됩니다:
- **비동기 작업**: 네트워크 호출, 파일 입출력, 데이터베이스 액세스.
- **병렬 처리**: 복잡한 연산을 병렬로 수행할 때.
- **UI 업데이트**: 백그라운드 작업 후 UI를 업데이트할 때.

### 8. **코루틴 사용 시 주의점**

코루틴을 사용할 때 주의해야 할 사항:
- **코루틴 취소**: 작업이 필요 이상 오래 걸릴 경우 적절히 취소해야 합니다.
- **리소스 누수**: 코루틴이 취소되지 않고 계속 실행될 경우 리소스 누수가 발생할 수 있습니다.
- **컨텍스트 전환 비용**: 지나치게 많은 컨텍스트 전환은 성능에 부정적인 영향을 미칠 수 있습니다.

---
### 1. **AOP란?**

#### 정의:
AOP는 **관점 지향 프로그래밍**이라고 하며, 소프트웨어 개발에서 **핵심 로직**과 **공통 관심사**를 분리하여 관리하는 프로그래밍 패러다임입니다.

#### 주요 개념:
- **핵심 로직**: 비즈니스 로직과 같이 애플리케이션의 주요 기능을 담당하는 코드.
- **공통 관심사**: 로깅, 보안, 트랜잭션 관리 등 여러 곳에서 공통적으로 적용되는 부가적인 로직.

AOP를 사용하면 코드 중복을 줄이고, 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

### 2. **AOP의 주요 구성 요소**

#### 1. **Aspect (애스펙트)**
- **정의**: 애플리케이션에서 특정 횡단 관심사를 모듈화한 것.
- **예**: 로깅, 보안, 트랜잭션 관리 등.

#### 2. **Join Point (조인 포인트)**
- **정의**: 애스펙트가 실행될 수 있는 특정 지점. 메서드 호출, 객체 생성 등 다양한 시점이 포함됩니다.
- **예**: 메서드 실행 전후, 예외 발생 시.

#### 3. **Advice (어드바이스)**
- **정의**: 특정 Join Point에서 수행할 실제 코드(로직).
- **종류**:
  - **Before**: 메서드 실행 전에 수행.
  - **After**: 메서드 실행 후에 수행.
  - **Around**: 메서드 실행 전후 모두에서 수행.
  - **AfterReturning**: 메서드가 정상적으로 종료된 후 실행.
  - **AfterThrowing**: 메서드가 예외를 던진 후 실행.

#### 4. **Pointcut (포인트컷)**
- **정의**: Join Point의 부분 집합으로, 어떤 Join Point에 Advice를 적용할지 결정하는 표현식.
- **예**: 특정 패키지 내 모든 메서드에 로깅 적용.

#### 5. **Weaving (위빙)**
- **정의**: 애스펙트를 핵심 코드에 적용하는 과정. 이 과정은 컴파일 시점, 로드 시점, 런타임 시점에 이루어질 수 있습니다.

### 3. **AOP 사용 사례**

#### 1. **로깅(logging)**
- 모든 메서드 호출 전에 로그를 남기고, 호출 후에도 결과를 기록하는 경우.
- 예: 사용자가 애플리케이션에서 어떤 기능을 실행했는지 기록.

#### 2. **트랜잭션 관리**
- 데이터베이스 작업 전후에 트랜잭션을 시작하고 종료하는 로직을 처리.
- 예: 비즈니스 로직이 성공적으로 완료되면 트랜잭션을 커밋하고, 예외가 발생하면 롤백.

#### 3. **보안(security)**
- 메서드가 호출되기 전에 사용자 권한을 확인하여 접근을 제어.
- 예: 관리자 권한이 없는 사용자는 특정 기능에 접근하지 못하도록 설정.

### 4. **AOP를 사용할 때 주의할 점**

#### 1. **과도한 AOP 사용**
- **주의**: 모든 기능에 AOP를 적용하면 코드 복잡도가 증가하고 디버깅이 어려워질 수 있습니다.
- **해결**: 핵심 비즈니스 로직과 공통 관심사를 적절히 분리하여, 필요한 곳에만 AOP를 적용합니다.

#### 2. **성능 문제**
- **주의**: Join Point가 많아지면, 런타임 시점에서의 성능 저하가 발생할 수 있습니다.
- **해결**: 성능에 민감한 부분에서는 Join Point의 범위를 최소화하거나, 애스펙트 적용을 줄입니다.

#### 3. **디버깅과 테스트**
- **주의**: AOP는 코드 흐름을 동적으로 변경하므로, 디버깅과 테스트가 어려워질 수 있습니다.
- **해결**: AOP가 적용된 코드와 적용되지 않은 코드를 명확히 구분하고, 테스트 케이스를 철저히 작성합니다.

#### 4. **의존성 관리**
- **주의**: AOP를 적용할 때는 **AspectJ**, **Spring AOP** 같은 라이브러리와의 의존성을 잘 관리해야 합니다.
- **해결**: 프로젝트 환경에 맞는 AOP 구현을 선택하고, 라이브러리 버전을 주기적으로 점검합니다.

### 5. **Spring AOP vs AspectJ**

#### Spring AOP:
- **기반**: 프록시 패턴 기반으로 동작하며, 런타임 시점에서만 AOP 기능을 제공합니다.
- **사용 사례**: 주로 스프링 컨테이너 관리 하의 빈에 적용.
- **장점**: 스프링과의 강력한 통합으로 설정과 관리가 쉬움.

#### AspectJ:
- **기반**: 바이트 코드 조작을 통해 컴파일 시점, 로드 시점, 런타임 시점에 AOP 기능을 제공합니다.
- **사용 사례**: 더 정교하고 강력한 AOP 기능이 필요할 때 사용.
- **장점**: 더 많은 Join Point와 포인트컷 표현식을 지원.

AOP는 공통 관심사를 효과적으로 관리함으로써 코드의 가독성과 유지보수성을 향상시키는 데 매우 유용합니다. 하지만 과도한 사용은 오히려 복잡도를 증가시킬 수 있으므로 신중한 설계와 적용이 필요합니다.

---
### 1. **비동기 프레임워크 종류**

비동기 프로그래밍을 지원하는 다양한 프레임워크가 존재합니다. 주요 비동기 프레임워크는 다음과 같습니다:

#### 1. **JavaScript/Node.js**
- **특징**: Node.js는 단일 스레드 이벤트 루프 기반의 비동기 I/O를 지원하여 고성능의 비동기 서버를 구축할 수 있습니다.
- **사용법**: **Promise**, **async/await**를 사용하여 비동기 작업을 관리합니다.

#### 2. **Spring WebFlux (Java)**
- **특징**: Spring의 리액티브 프로그래밍 프레임워크로, 논블로킹 I/O를 지원하여 대규모 트래픽을 처리할 수 있습니다.
- **사용법**: **Mono**, **Flux**를 사용하여 비동기 스트림을 처리합니다.

#### 3. **CompletableFuture (Java)**
- **특징**: Java 8부터 제공되는 **CompletableFuture**를 사용하여 비동기 프로그래밍을 쉽게 구현할 수 있습니다.
- **사용법**: **thenApply**, **thenCompose** 등의 메서드를 사용하여 비동기 작업 체인을 구성합니다.

#### 4. **.NET의 Task 기반 비동기 프로그래밍**
- **특징**: **Task**와 **async/await** 키워드를 사용하여 비동기 작업을 작성할 수 있습니다.
- **사용법**: 비동기 메서드를 작성하고 **await** 키워드로 비동기 작업의 결과를 기다립니다.

#### 5. **Python의 Asyncio**
- **특징**: Python에서 비동기 프로그래밍을 지원하는 **asyncio** 모듈을 사용하여 효율적인 비동기 코드 작성을 지원합니다.
- **사용법**: **async/await** 키워드를 사용하여 비동기 작업을 정의합니다.

### 2. **비동기 처리를 할 때 고려해야 할 사항(아키텍처 적으로)**

비동기 처리를 효과적으로 설계하기 위해 다음 사항들을 고려해야 합니다:

#### 1. **스레드 관리**
- 비동기 작업이 많아지면 스레드 풀의 크기를 적절히 설정해야 합니다.
- 스레드가 과도하게 생성되거나 블로킹되지 않도록 관리해야 합니다.

#### 2. **리소스 관리**
- 비동기 작업이 I/O나 네트워크 리소스를 효율적으로 사용하도록 설계해야 합니다.
- **논블로킹 I/O**를 활용하여 리소스를 최적화합니다.

#### 3. **에러 처리**
- 비동기 작업 중 발생하는 예외를 적절히 처리할 수 있는 구조를 설계해야 합니다.
- 예: **try/catch** 블록이나 **onErrorResume**, **exceptionally**와 같은 메서드를 사용하여 예외를 관리합니다.

#### 4. **데이터 일관성**
- 비동기 작업 중 데이터 일관성을 유지하기 위한 적절한 트랜잭션 관리가 필요합니다.
- 예: 비동기 작업에서 ACID 특성을 보장할 수 있도록 설계해야 합니다.

#### 5. **확장성**
- 비동기 작업이 증가할 때 시스템이 확장 가능하도록 설계해야 합니다.
- **로드 밸런싱**, **분산 처리**를 고려하여 아키텍처를 설계합니다.

### 3. **비동기의 단점과 주의사항**

#### 단점:
1. **복잡한 디버깅**:
   - 비동기 코드의 흐름이 복잡해져 디버깅이 어려울 수 있습니다.
   - **스택 트레이스**가 비동기 호출 간 연결되지 않을 수 있어 문제가 발생한 지점을 찾기 어렵습니다.

2. **코드 가독성 저하**:
   - 콜백 헬로 인한 가독성 저하 문제가 발생할 수 있습니다.
   - 이를 해결하기 위해 **Promise**나 **async/await** 같은 구조를 사용하여 코드 가독성을 향상시킬 수 있습니다.

3. **리소스 관리의 어려움**:
   - 비동기 작업이 예상보다 오래 지속되거나 리소스를 과도하게 사용하는 경우, 시스템 자원을 고갈시킬 수 있습니다.
   - 적절한 타임아웃 설정과 리소스 해제가 필요합니다.

4. **상태 관리의 어려움**:
   - 비동기 작업이 동시에 실행될 경우, 상태 관리를 적절히 하지 않으면 데이터 일관성 문제가 발생할 수 있습니다.
   - 공유 자원을 적절히 보호하고 동기화 메커니즘을 적용해야 합니다.

#### 주의사항:
1. **비동기 API 설계**:
   - 비동기 메서드를 호출하는 클라이언트가 쉽게 사용할 수 있도록 API 설계에 신경 써야 합니다.
   - **Future**, **Callback** 등 명확한 비동기 인터페이스를 제공해야 합니다.

2. **타임아웃 관리**:
   - 비동기 작업에 대한 타임아웃을 설정하여 무한 대기 상태를 방지해야 합니다.
   - 타임아웃이 초과되었을 때 적절히 작업을 취소하거나 대체 로직을 수행해야 합니다.

3. **데드락 방지**:
   - 비동기 작업이 서로 의존 관계에 있을 때, 데드락이 발생하지 않도록 주의해야 합니다.
   - 특히 **lock**을 사용할 때 주의해야 하며, 논블로킹 방식으로 설계하는 것이 좋습니다.

4. **로드 테스트**:
   - 비동기 시스템은 예기치 못한 부하에서 성능 문제가 발생할 수 있으므로, 충분한 로드 테스트를 통해 시스템의 한계를 미리 파악해야 합니다.

---
### 1. **파티셔닝과 샤딩의 차이**

#### 파티셔닝 (Partitioning)
- **정의**: 하나의 데이터베이스 테이블을 **로우(row)** 단위로 나누어 여러 파티션으로 분할하는 기술입니다.
- **목적**: 데이터 접근 속도 향상, 관리 편의성.
- **종류**:
  - **범위 파티셔닝**: 특정 범위 값에 따라 데이터를 분할.
    - 예: 날짜에 따라 데이터를 나누는 경우.
  - **리스트 파티셔닝**: 특정 값 목록에 따라 데이터를 분할.
  - **해시 파티셔닝**: 해시 함수로 분산하여 데이터 균등 분배.
  
#### 샤딩 (Sharding)
- **정의**: 데이터베이스를 여러 개의 **서버**에 나누어 저장하는 방식으로, 각 서버는 특정 부분의 데이터를 담당합니다.
- **목적**: 수평적 확장(Scalability)으로 더 많은 데이터를 처리할 수 있도록 함.
- **특징**:
  - 각 샤드(Shard)는 독립된 데이터베이스처럼 동작하며, 특정 데이터 범위를 처리합니다.
  - 샤딩 키(Sharding Key)를 사용하여 데이터를 나누고 라우팅합니다.
  
#### 차이점:
- **파티셔닝**은 하나의 데이터베이스 내에서 데이터를 나누는 방식이며, **샤딩**은 데이터베이스 자체를 여러 서버에 나누는 방식입니다.
- **파티셔닝**은 주로 데이터의 **읽기/쓰기 성능** 최적화에 중점을 둡니다.
- **샤딩**은 **시스템 확장성**과 **고가용성**에 중점을 둡니다.

### 2. **JdbcTemplate, MyBatis, JPA, QueryDSL의 장단점과 차이점**

#### 1. **JdbcTemplate**
- **장점**:
  - JDBC의 보일러플레이트 코드(예: 연결 관리, 예외 처리)를 줄여줍니다.
  - 간단한 쿼리 작업에 적합하며, 사용이 쉬움.
- **단점**:
  - SQL을 직접 작성해야 하므로, 복잡한 쿼리는 코드가 길어질 수 있습니다.
  - 객체와 SQL 간 매핑이 수동적이므로 유지보수가 어려울 수 있습니다.

#### 2. **MyBatis**
- **장점**:
  - SQL을 XML로 관리하여 가독성과 재사용성을 높입니다.
  - 쿼리 결과를 객체로 매핑하는 기능을 제공.
  - 복잡한 SQL을 효율적으로 관리할 수 있습니다.
- **단점**:
  - SQL 의존성이 높아 SQL 변경 시 많은 수정이 필요할 수 있습니다.
  - 설정과 매핑 파일 관리가 복잡해질 수 있습니다.

#### 3. **JPA (Java Persistence API)**
- **장점**:
  - 객체 지향 프로그래밍 방식으로 데이터를 다룰 수 있도록 지원하며, 개발자가 SQL을 직접 작성할 필요가 적습니다.
  - **캐시**, **트랜잭션 관리**, **지연 로딩** 등 고급 기능을 지원.
- **단점**:
  - 복잡한 쿼리를 작성할 때는 JPQL(HQL)이나 Native Query를 사용해야 하며, 이 과정이 복잡할 수 있습니다.
  - **N+1 문제** 등 최적화에 신경 써야 하는 부분이 많습니다.

#### 4. **QueryDSL**
- **장점**:
  - 타입 안전한 쿼리 작성이 가능하며, IDE에서 자동 완성 지원.
  - JPA와 함께 사용하여 정적 타입 기반의 쿼리를 쉽게 작성할 수 있습니다.
- **단점**:
  - 초기 설정이 복잡하며, 도메인 클래스가 많아질수록 코드량이 늘어날 수 있습니다.

### 3. **테이블 설계 시 중요 요소**

#### 1. **정규화**:
- 데이터 중복을 최소화하고, 데이터 무결성을 유지하기 위해 테이블을 정규화합니다.

#### 2. **인덱스**:
- 적절한 인덱스를 설계하여 데이터 조회 속도를 향상시킵니다. 그러나 인덱스가 너무 많으면 쓰기 성능에 영향을 미칠 수 있습니다.

#### 3. **키 설계**:
- **기본 키(Primary Key)**와 **외래 키(Foreign Key)**의 올바른 설계가 중요합니다. 기본 키는 유일성과 무결성을 보장합니다.

#### 4. **데이터 타입**:
- 각 컬럼에 적절한 데이터 타입을 설정하여 저장 공간과 성능을 최적화합니다.

#### 5. **참조 무결성**:
- 데이터 간의 관계를 명확히 정의하여 참조 무결성을 보장합니다.

#### 6. **파티셔닝 및 샤딩 고려**:
- 대규모 데이터를 다룰 경우, 파티셔닝과 샤딩을 고려하여 설계합니다.

### 4. **JPA 사용할 때 문제가 될 수 있는 부분**

#### 1. **N+1 문제**:
- **정의**: 하나의 조회 쿼리로 다수의 추가 쿼리가 발생하는 문제.
- **해결 방법**: **Fetch Join**이나 **EntityGraph**를 사용하여 해결합니다.

#### 2. **지연 로딩(Lazy Loading)**:
- **정의**: 연관된 데이터를 실제로 사용할 때 로딩하는 방식.
- **문제점**: 필요 이상의 쿼리가 발생하거나 **LazyInitializationException**이 발생할 수 있습니다.
- **해결 방법**: **즉시 로딩(Eager Loading)**이나 **Fetch Join**을 사용합니다.

#### 3. **캐싱과 동시성 문제**:
- JPA는 1차 캐시와 2차 캐시를 제공하지만, 잘못 사용하면 동시성 문제가 발생할 수 있습니다.
  
#### 4. **엔티티 상태 관리**:
- 영속성 컨텍스트에서 엔티티 상태(Managed, Detached)를 제대로 관리하지 않으면 데이터 불일치가 발생할 수 있습니다.

### 5. **JPA 사용 시 고아 객체, 엔티티 순회 이슈**

#### 1. **고아 객체(Orphan Removal) 문제**:
- 부모 엔티티에서 자식 엔티티를 제거할 때 고아 객체가 데이터베이스에 남아 있을 수 있습니다.
- **해결 방법**: **@OneToMany**와 함께 **orphanRemoval=true**를 설정하여 부모가 삭제될 때 자식도 자동으로 삭제되도록 합니다.

#### 2. **엔티티 순회 문제**:
- 양방향 연관 관계에서 엔티티 순회 시 무한 루프가 발생할 수 있습니다.
- **해결 방법**: **@JsonIgnore** 또는 **DTO**를 사용하여 순환 참조를 방지합니다.

### 6. **트랜잭션이 처리되는 과정**

#### 1. **트랜잭션 시작**:
- 트랜잭션 매니저가 **@Transactional** 어노테이션을 통해 트랜잭션을 시작합니다.

#### 2. **트랜잭션 경계 내 작업 수행**:
- 데이터베이스 작업이 트랜잭션 내에서 이루어지며, 오류가 발생하면 롤백됩니다.

#### 3. **커밋 또는 롤백**:
- 모든 작업이 성공하면 트랜잭션이 커밋되고, 오류가 발생하면 롤백됩니다.

